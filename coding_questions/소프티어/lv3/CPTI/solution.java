// https://softeer.ai/practice/11002

import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        // 빠른 입력을 위한 BufferedReader와 StringTokenizer 사용
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());

        // 각 CPTI bitmask에 대한 등장 횟수를 저장하는 맵
        HashMap<Integer, Integer> freq = new HashMap<>();
        for (int i = 0; i < N; i++) {
            String s = br.readLine().trim();
            // 이진 문자열을 정수로 변환 (base 2)
            int bitmask = Integer.parseInt(s, 2);
            freq.put(bitmask, freq.getOrDefault(bitmask, 0) + 1);
        }

        // 모든 서로 다른 CPTI(정수)의 키를 정렬된 리스트로 변환
        ArrayList<Integer> keys = new ArrayList<>(freq.keySet());
        Collections.sort(keys);

        long result = 0;

        // [해밍 거리 0] 동일한 CPTI를 가진 사람 쌍: C(n,2)
        for (int key : keys) {
            int count = freq.get(key);
            result += (long) count * (count - 1) / 2;
        }

        // [해밍 거리 1 또는 2]
        // 각 CPTI에 대해 한 자리 또는 두 자리만 다르게 바꾼 경우의 이웃들을 확인
        // 이때, 한 쌍을 중복해서 세지 않도록 "neighbor > key" 인 경우만 처리합니다.
        for (int key : keys) {
            int countKey = freq.get(key);

            // 해밍 거리 1: 한 비트만 flip
            for (int i = 0; i < M; i++) {
                int neighbor = key ^ (1 << i);
                if(neighbor > key && freq.containsKey(neighbor)){
                    int countNeighbor = freq.get(neighbor);
                    result += (long) countKey * countNeighbor;
                }
            }

            // 해밍 거리 2: 두 비트를 flip (i < j)
            for (int i = 0; i < M; i++) {
                for (int j = i + 1; j < M; j++) {
                    int neighbor = key ^ (1 << i) ^ (1 << j);
                    if(neighbor > key && freq.containsKey(neighbor)){
                        int countNeighbor = freq.get(neighbor);
                        result += (long) countKey * countNeighbor;
                    }
                }
            }
        }

        System.out.println(result);
    }
}


/*

코드 설명
입력 처리 및 변환

각 사람의 CPTI(이진 문자열)를 정수(bitmask)로 변환합니다. 예를 들어, "101"은 정수 5가 됩니다.
HashMap<Integer, Integer>를 사용하여 각 bitmask의 등장 횟수를 저장합니다.
동일한 CPTI인 경우 (해밍 거리 0)

같은 bitmask를 가진 사람들 사이의 쌍의 수는 조합 (count)C(2)로 계산합니다.
해밍 거리 1, 2 인 경우

각 bitmask key에 대해, 한 자리만 flip한 이웃(bitmask)들을 생성합니다.
또한, 두 자리만 flip한 이웃들을 생성합니다.
한 쌍을 중복해서 세지 않도록 생성한 neighbor가 key보다 클 때만 결과에 추가합니다.
출력

최종 결과를 출력합니다.

 */

/*

1. 비트마스크(Bitmask)와 비트 연산(Bitwise Operations)
비트마스크
사람의 성격을 나타내는 CPTI가 길이
𝑀
M의 이진 문자열로 주어지는데, 이를 정수로 변환하여 비트마스크로 사용합니다. 예를 들어, 문자열 "101"은 2진수
101
2
101
2
​
  즉, 십진수 5로 표현할 수 있습니다.
장점: 정수로 변환하면 각 자리(비트)에 대해 빠르게 연산할 수 있으며, 메모리 사용도 효율적입니다.

비트 연산
비트마스크를 사용하면 AND, OR, XOR, SHIFT 등의 비트 연산을 활용할 수 있습니다.

XOR: 두 비트가 다를 때 1이 되는 연산으로, 두 비트마스크의 차이를 알아내거나 특정 비트를 반전(flip)하는 데 유용합니다.
Shift: 특정 비트를 위치시키기 위해 사용됩니다.
이 문제에서는 한 자리 또는 두 자리만 다른(해밍 거리 1 또는 2) 이웃의 비트마스크를 생성하기 위해, 특정 비트를 반전하는 연산(예: key ^ (1 << i))을 사용합니다.

2. 해밍 거리(Hamming Distance)
정의:
두 이진 문자열 간의 해밍 거리는 서로 다른 위치의 비트 수를 의미합니다.

문제 적용:
두 사람의 CPTI가 최대 2자리만 다르면 친밀감을 느낀다고 했으므로, 해밍 거리가 0, 1 또는 2인 경우를 찾아야 합니다.

해밍 거리 0: 동일한 CPTI일 때.
해밍 거리 1: 한 자리만 다른 경우.
해밍 거리 2: 두 자리만 다른 경우.
비트마스크와 XOR의 활용:
두 비트마스크 간의 XOR 연산을 수행하면, 서로 다른 비트에 대해서만 1이 나오므로, 이 결과에서 1의 개수를 세면 해밍 거리를 알 수 있습니다.
그러나 모든 두 사람 간의 해밍 거리를 직접 계산하면
𝑂
(
𝑁
2
)
O(N
2
 ) 시간이 소요되므로, 해밍 거리가 1 또는 2인 후보를 미리 생성하는 방식으로 접근합니다.

3. 조합(Combination) 연산
동일한 CPTI인 경우:
같은 비트마스크를 가진 사람들 사이의 쌍의 수는 조합
𝐶
(
𝑛
,
2
)
=
𝑛
(
𝑛
−
1
)
2
C(n,2)=
2
n(n−1)
​
 를 통해 계산할 수 있습니다.

서로 다른 CPTI인 경우:
예를 들어, 어떤 비트마스크 A와 해밍 거리 1 또는 2 차이가 나는 비트마스크 B가 존재한다면, 두 그룹의 빈도수를 곱하여 가능한 쌍의 수를 계산할 수 있습니다.

4. 해시맵(HashMap)을 이용한 빈도수 계산
목적:
입력된 모든 사람의 CPTI(비트마스크) 값에 대해, 각 값이 몇 번 등장하는지 저장합니다.

사용:
Java의 HashMap<Integer, Integer>를 이용하여, key를 비트마스크, value를 등장 횟수로 저장합니다. 이를 통해 동일한 CPTI에 대해서도, 그리고 이웃 비트마스크가 존재하는지 빠르게 확인할 수 있습니다.

5. 중복 계산 방지
문제:
두 사람 A와 B를 계산할 때 (A, B)와 (B, A)가 같은 쌍이므로, 같은 쌍을 중복해서 세지 않아야 합니다.

해결 방법:
비트마스크를 정렬하거나, 특정 기준(예: 현재 처리하는 비트마스크보다 값이 큰 경우만)을 적용하여, 각 쌍을 한 번만 계산합니다.

6. 시간 복잡도 최적화
문제 상황:
𝑁
N이 최대 30,000이고, 모든 두 사람의 쌍에 대해 직접 비교하면
𝑂
(
𝑁
2
)
O(N
2
 )가 되어 너무 느립니다.

최적화 전략:

각 사람의 CPTI를 비트마스크로 변환한 후, 같은 값끼리의 빈도만 기록합니다.
각 유니크한 비트마스크에 대해, M개의 비트를 각각 반전시키거나 두 개를 반전시켜 해밍 거리 1 또는 2에 해당하는 이웃들을 생성합니다.
𝑀
M이 최대 30이므로, 각 비트마스크 당 최대
𝑀
+
(
𝑀
2
)
M+(
2
M
​
 ) (약 30 + 435 = 465번) 연산하면 됩니다.
이렇게 함으로써 전체 연산 횟수를
(유니크한 비트마스크 수)
×
465
(유니크한 비트마스크 수)×465 정도로 제한할 수 있으며, N이 30,000일 때도 충분히 빠르게 처리할 수 있습니다.
정리하면,
문제를 풀기 위해 필요한 알고리즘 개념은 다음과 같습니다:

비트마스크와 비트 연산: 이진 문자열을 정수로 변환하여 각 자리의 연산(특정 비트 반전 등)을 쉽게 수행할 수 있음.
해밍 거리: 두 비트마스크 간의 차이를 나타내며, 최대 2자리만 다른 경우를 찾아내기 위한 핵심 개념.
조합 계산: 동일한 CPTI를 가진 사람들 사이의 쌍 계산 및 서로 다른 CPTI 간의 빈도수 곱을 통해 쌍의 수를 계산.
해시맵을 통한 빈도수 관리: 각 비트마스크의 등장 횟수를 빠르게 조회하고 관리.
중복 계산 방지: (A, B)와 (B, A) 같은 중복을 피하기 위한 처리.
시간 복잡도 최적화:
𝑁
2
N
2
 의 직접 계산 대신, 유니크한 비트마스크와 그 이웃(해밍 거리 1, 2)을 효율적으로 생성하여 문제 해결.

 */


/*

해밍 거리는 두 이진 문자열(또는 비트마스크) 사이에서 서로 다른 비트의 개수를 의미합니다. 문제에서는 두 사람의 성격이 최대 2개의 영역에서만 다르면 친밀감을 느낀다고 했으므로, 해밍 거리가 0, 1, 2인 경우에 해당하는 쌍을 모두 찾아야 합니다.

그런데 해밍 거리 1과 해밍 거리 2를 구하는 방식은 반전시키는 비트의 수가 다르기 때문에 서로 다른 방법으로 접근해야 합니다.

해밍 거리 1인 경우
한 개의 비트만 반전:
예를 들어, CPTI가 101인 경우, 한 비트만 반전하면 001, 111, 100과 같이 세 가지 경우가 나옵니다.
구현:
for (int i = 0; i < M; i++) { int neighbor = key ^ (1 << i); ... }
여기서 1 << i는 오직 하나의 비트만 1인 값을 만듭니다. 이 값을 XOR 연산하면 key의 i번째 비트만 반전되므로, 해밍 거리가 1인 이웃(bitmask)을 구할 수 있습니다.
해밍 거리 2인 경우
두 개의 비트 동시에 반전:
같은 예시에서 101의 경우, 두 비트를 반전하면 여러 가지 결과가 나오게 됩니다. 예를 들어, 첫 번째와 두 번째 비트를 반전하면 010가 되고, 첫 번째와 세 번째 비트를 반전하면 011 등이 됩니다.
구현:
for (int i = 0; i < M; i++) { for (int j = i + 1; j < M; j++) { int neighbor = key ^ (1 << i) ^ (1 << j); ... } }
이중 for문을 사용하여 가능한 모든 두 비트 조합에 대해 반전시키므로, 해밍 거리가 2인 모든 neighbor를 구할 수 있습니다.
왜 분리하는가?
반전 비트의 수가 다름:

해밍 거리 1은 한 비트만 반전시키면 되고,
해밍 거리 2는 두 비트를 반전시켜야 합니다.
이 두 경우는 자연스럽게 각각 다른 반복문 구조를 갖게 됩니다.

경우의 수와 처리 방식이 다름:

해밍 거리 1인 경우에는
𝑀
M번의 반복으로 가능한 neighbor를 구할 수 있습니다.
해밍 거리 2인 경우에는
(
𝑀
2
)
(
2
M
​
 ) (즉,
𝑀
(
𝑀
−
1
)
2
2
M(M−1)
​
 ) 번의 반복이 필요합니다.
두 경우를 하나의 반복문에서 처리하기보다는, 각각 독립적으로 처리하는 것이 코드의 가독성과 유지보수 측면에서도 좋습니다.

중복 방지 및 로직의 명확화:
각 경우마다 neighbor를 구하는 방법과 그에 따른 조건(예: neighbor > key 등)이 다를 수 있으므로, 분리하여 명확하게 작성하면 중복 계산을 피하고 올바른 쌍을 세기 쉽습니다.

결론적으로, 해밍 거리가 1과 2인 경우는 비트 반전 횟수가 다르고, 각각의 경우에 대해 처리해야 하는 경우의 수도 다르기 때문에 이를 분리해서 처리하는 것입니다. 이를 통해 각 상황에 맞게 정확하고 효율적으로 neighbor를 생성하고, 친밀감을 느끼는 사람 쌍의 수를 올바르게 계산할 수 있습니다.

 */