// https://softeer.ai/practice/6249

import java.io.*;
import java.util.*;

public class Main {
    // 패턴(좋은 염기서열)의 개수와 각 패턴의 길이
    static int numPatterns, seqLength;
    // 입력으로 주어진 패턴들을 저장하는 배열
    static String[] patterns;
    // 모든 패턴을 커버하기 위해 필요한 최소 그룹(초염기서열)의 수
    static int bestSolution;

    public static void main(String[] args) throws Exception {
        // 입력 처리: BufferedReader와 StringTokenizer를 사용하여 빠르게 처리
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        numPatterns = Integer.parseInt(st.nextToken());
        seqLength = Integer.parseInt(st.nextToken());
        patterns = new String[numPatterns];
        for (int i = 0; i < numPatterns; i++){
            patterns[i] = br.readLine().trim();
        }

        // 최악의 경우: 각 패턴을 개별 그룹에 배정해야 하므로 최대 그룹 수는 numPatterns
        bestSolution = numPatterns;

        // 그룹 리스트: 각 그룹은 길이 seqLength의 char 배열로 관리됨.
        // 각 그룹의 배열은 해당 그룹의 '제약'을 나타내며,
        // 아직 제약이 없는 자리는 '*'로 표현 (즉, 아무 문자나 들어갈 수 있음)
        ArrayList<char[]> currentGroups = new ArrayList<>();

        // 백트래킹 시작: 패턴 0부터 numPatterns-1까지 배정해 나간다.
        backtrack(0, currentGroups);

        System.out.println(bestSolution);
    }

    /**
     * 백트래킹 메서드: 주어진 인덱스의 패턴부터 마지막 패턴까지를 현재 그룹들에 배정하는 모든 경우를 탐색합니다.
     *
     * @param patternIndex 현재 배정할 패턴의 인덱스
     * @param groups       현재까지 만들어진 그룹들의 리스트
     *                     (각 그룹은 길이 seqLength의 char 배열로, 각 위치에 제약 조건이 저장됨)
     */
    static void backtrack(int patternIndex, ArrayList<char[]> groups) {
        // 기저 사례: 모든 패턴을 그룹에 배정한 경우
        if (patternIndex == numPatterns) {
            bestSolution = Math.min(bestSolution, groups.size());
            return;
        }

        // 가지치기: 현재 사용한 그룹의 수가 이미 bestSolution 이상이면 더 이상 진행할 필요가 없음.
        if (groups.size() >= bestSolution) return;

        // 현재 배정할 패턴
        String currentPattern = patterns[patternIndex];

        // [1] 기존 그룹들에 현재 패턴을 추가할 수 있는지 시도합니다.
        for (int groupIndex = 0; groupIndex < groups.size(); groupIndex++) {
            char[] groupConstraints = groups.get(groupIndex);
            boolean canPlaceInGroup = true;
            // 그룹 상태를 변경하기 전 백업: 재귀 호출 후 상태를 복원하기 위함
            char[] backupConstraints = groupConstraints.clone();

            // 각 위치에 대해 현재 패턴과 그룹의 제약 조건이 호환되는지 확인
            for (int pos = 0; pos < seqLength; pos++) {
                char patternChar = currentPattern.charAt(pos);
                if (patternChar != '.') { // 패턴에 구체적인 문자가 있는 경우만 검사
                    if (groupConstraints[pos] == '*') {
                        // 아직 제약이 없다면, 현재 패턴의 문자를 제약으로 설정
                        groupConstraints[pos] = patternChar;
                    } else if (groupConstraints[pos] != patternChar) {
                        // 이미 설정된 제약과 불일치 → 이 그룹에 배정할 수 없음.
                        canPlaceInGroup = false;
                        break;
                    }
                }
            }

            // 만약 현재 그룹에 넣을 수 있다면, 다음 패턴으로 진행
            if (canPlaceInGroup) {
                backtrack(patternIndex + 1, groups);
            }
            // 재귀 호출 후 그룹의 상태를 원래대로 복원
            groups.set(groupIndex, backupConstraints);
        }

        // [2] 새로운 그룹을 생성하여 현재 패턴을 넣는 경우
        // 새로운 그룹의 제약 배열은 현재 패턴의 구체적인 문자로 초기화하고, '.'인 자리는 '*'로 표시
        char[] newGroupConstraints = new char[seqLength];
        for (int pos = 0; pos < seqLength; pos++) {
            char patternChar = currentPattern.charAt(pos);
            newGroupConstraints[pos] = (patternChar == '.') ? '*' : patternChar;
        }
        groups.add(newGroupConstraints);
        backtrack(patternIndex + 1, groups);
        groups.remove(groups.size() - 1);
    }
}

/* 설명

백트래킹을 이용한 풀이 방법의 원리 및 코드 적용 방식
문제의 핵심 아이디어

주어진 여러 개의 좋은 염기서열(패턴)을 몇 개의 그룹으로 나누는데,
한 그룹 내의 모든 패턴은 모든 위치에서
와일드 카드('.')는 어떤 문자와도 호환되고,
실제 문자가 있다면 해당 위치의 문자가 모두 동일해야 하므로 한 초염기서열(그룹)로 커버할 수 있습니다.
목표는 모든 패턴을 커버할 수 있는 최소 그룹(초염기서열) 수를 찾는 것입니다.
백트래킹(Backtracking)이란?

백트래킹은 가능한 모든 경우의 수(혹은 후보군)를 탐색하면서,
불가능하거나 (또는 최적 해보다 더 많은 자원을 사용하는) 경우 가지치기를 통해 탐색을 중단하는 방식입니다.
이 문제에서는 "패턴을 그룹에 배정하는" 모든 경우를 고려하되,
현재까지 사용한 그룹 수가 이미 현재까지의 최적 해(최소 그룹 수)보다 많아지면 더 이상 진행하지 않습니다.
코드에서의 백트래킹 적용 방식

재귀 함수 backtrack(int patternIndex, ArrayList<char[]> groups)
patternIndex: 지금까지 0번부터 patternIndex-1번까지의 패턴은 이미 그룹에 배정됨
groups: 현재까지 만들어진 그룹들의 리스트. 각 그룹은 길이 seqLength의 char 배열로,
각 위치에 해당하는 제약 조건(초염기서열을 결정하는 문자)이 저장되어 있습니다.
패턴을 기존 그룹에 추가하는 경우
현재 배정할 패턴을 각 기존 그룹에 넣어보고, 해당 그룹의 제약 조건과 충돌하는지 확인합니다.
만약 추가 가능하면(모든 위치에서 제약 조건을 만족하면) 재귀적으로 다음 패턴 배정을 진행합니다.
그룹에 추가하기 전에 현재 그룹 상태를 백업해두고, 재귀 호출 후에 복원합니다.
새로운 그룹을 생성하는 경우
현재 패턴을 이용하여 새로운 그룹(초염기서열)을 생성합니다.
이때, 패턴에 구체적인 문자가 있으면 해당 위치의 제약으로 설정하고, 와일드 카드('.')인 경우 자유롭게 설정('*'로 표시)합니다.
새 그룹을 추가한 후 재귀적으로 다음 패턴 배정을 진행하고, 재귀 후에는 새 그룹을 제거합니다.
가지치기(Pruning)
현재까지 사용한 그룹 수가 이미 bestSolution (현재까지 발견된 최소 그룹 수) 이상이면,
더 이상 진행할 필요 없이 즉시 재귀 호출을 종료합니다.
최종 결과

모든 패턴에 대해 그룹 배정이 완료되면, 사용된 그룹의 수가 하나의 해가 됩니다.
여러 경우 중 최소 그룹 수를 전역 변수 bestSolution에 저장하고, 최종적으로 출력합니다.



**groups**는 현재까지 만들어진 **그룹(초염기서열)**들을 저장하는 리스트입니다.
각 인덱스(예를 들어, groups.get(i))는 하나의 그룹을 나타내며, 이 그룹은 하나의 초염기서열을 구성할 수 있는 제약 조건들을 담고 있는 char[] 배열입니다.

char[] 배열의 역할
길이: 배열의 길이는 입력 패턴의 길이 M과 동일합니다.

각 요소의 의미:
배열의 각 인덱스(위치)는 초염기서열의 한 자리(염기 자리)를 나타냅니다.
해당 위치에 저장된 char 값은 그 그룹에 속한 패턴들을 모두 커버하기 위해 해당 위치에서 반드시 가져야 하는 문자를 의미합니다.
만약 아직 그 위치에 대해 특정 제약(문자)이 정해지지 않았다면 '*' 기호를 사용하여 "아직 자유로운 상태"임을 표시합니다.
예를 들어, 그룹의 배열이 ['a', '*', 'g', '*']라면,
0번째 위치는 반드시 'a'여야 하고,
2번째 위치는 반드시 'g'여야 하며,
1번째와 3번째 위치는 아직 어떤 문자도 들어올 수 있는 자유로운 상태임을 의미합니다.


그룹에 패턴을 추가할 때
새로운 패턴을 기존 그룹에 추가할 때,
각 위치에서 패턴의 문자를 그룹의 제약 조건과 비교합니다.
패턴의 해당 위치 문자가 '.'인 경우:
와일드 카드이므로, 아무 문자와도 충돌하지 않고 추가가 가능합니다.
패턴의 해당 위치 문자가 실제 문자(예: 'a', 'c', 'g', 't')인 경우:
만약 그룹의 해당 위치가 아직 '*' (제약 없음)라면,
해당 문자를 제약으로 설정합니다.
만약 그룹의 해당 위치가 이미 다른 문자로 설정되어 있다면,
그 그룹에는 현재 패턴을 추가할 수 없습니다.


즉, 각 그룹의 char[] 값은 그 그룹이 앞으로 어떤 초염기서열을 만들어야 하는지에 대한 **"조건"**을 나타내며, 그룹에 속한 모든 패턴은 이 조건을 만족해야 합니다.
이런 방식으로, 여러 패턴들이 하나의 초염기서열로 커버 가능한지 판단하고, 최소 그룹 수를 찾기 위해 백트래킹으로 모든 경우를 탐색하게 됩니다.
 */

/*
1. 문제 이해
문제 상황:

입력:
𝑁
N개의 좋은 염기서열(패턴), 각 패턴의 길이는
𝑀
M.
각 패턴은 a, c, g, t 또는 와일드 카드 .로 구성됨.
목표:
주어진 모든 패턴을 “커버(만족)”하는 초염기서열들을 최소 개수로 만들고자 함.
한 초염기서열은 여러 패턴을 커버할 수 있는데, 한 그룹의 모든 패턴은 각 위치별로
패턴에 실제 문자가 있다면 모두 같은 문자여야 하고,
패턴에 .가 있으면 어떤 문자여도 상관없다.
즉, 문제는 “패턴들을 몇 개의 그룹으로 분할할 것인가?”이고, 각 그룹은 호환 가능한 패턴들의 모임이어야 합니다.

2. 그룹(초염기서열) 내 패턴의 호환 조건 정의
호환 조건:

그룹 내 모든 패턴에 대해,
각 위치 j (0 ≤ j < M)에서:
만약 어떤 패턴이 와일드 카드 .를 제외한 실제 문자를 갖는다면,
그룹 내 모든 패턴은 그 위치에서 같은 문자여야 함.
아이디어:

한 그룹이 커버할 수 있는 초염기서열은 **각 위치에 대해 “제약 조건”**을 가집니다.
예를 들어, 그룹의 제약 조건을 길이
M의 배열로 표현하면,
아직 제약이 없으면 '*' 또는 비어있는 상태로 표현,
어떤 패턴을 추가하면서 특정 위치에 문자 a가 나온다면 그 자리는 'a'라는 제약을 갖게 됩니다.
이렇게 각 그룹은 “초염기서열로 최종 만들어져야 하는 문자”에 대한 조건 집합이 됩니다.

3. 백트래킹 접근 방법 구상
문제를 백트래킹으로 풀려면 “각 패턴을 어느 그룹에 배정할지” 결정하는 문제로 볼 수 있습니다.
즉,
패턴들을 순서대로 (예: 인덱스 0부터 N−1) 하나씩 선택하여,
현재까지 생성된 그룹들 중 한 곳에 넣거나, 아니면 새로운 그룹을 만들어 넣습니다.
각 단계에서 해야 할 일:

현재 패턴을 기존 그룹에 배정하는 경우:

각 기존 그룹마다 “이 패턴을 넣어도 그룹의 제약 조건과 충돌하지 않는지” 확인합니다.
검사 방법:
그룹의 제약 배열(예, char[])와 현재 패턴의 각 위치를 비교.
현재 패턴의 해당 위치가 .이면 아무 영향이 없고,
실제 문자인 경우:
해당 그룹의 제약이 '*' (즉, 아직 정해지지 않음)이면, 해당 문자를 제약으로 설정.
이미 제약이 있다면 그 문자와 일치하는지 확인.
만약 어떤 그룹에서 호환된다면, 해당 그룹에 배정하고 재귀 호출로 다음 패턴으로 넘어갑니다.
중요: 재귀 호출 전에 그룹의 상태(제약 배열)를 백업해두고, 재귀 후에는 원래 상태로 복원합니다.
현재 패턴을 새 그룹에 배정하는 경우:

현재 패턴을 기반으로 새로운 그룹을 생성합니다.
새 그룹의 제약 배열은,
각 위치에서 패턴에 구체적인 문자가 있으면 그 문자,
.이면 여전히 자유로운 상태('*')로 초기화합니다.
새 그룹을 추가하고 재귀 호출로 다음 패턴을 처리한 뒤, 재귀가 끝나면 새 그룹을 제거합니다.
가지치기 (Pruning):

만약 현재까지 사용한 그룹 수가 이미 찾은 최소 해(최적 해)보다 크거나 같다면,
더 이상 진행하지 않고 바로 돌아갑니다.
이는 백트래킹의 중요한 부분으로, 불필요한 탐색을 줄여줍니다.
4. 왜 백트래킹인가?
백트래킹은 모든 가능한 배정(분할)을 시도하면서,
“이 배정은 이미 최적해보다 좋지 않다”라고 판단되면 그 가지를 더 이상 탐색하지 않는 기법입니다.
이 문제의 경우,
𝑁
N이 최대 15이므로 가능한 배정 경우의 수는 많지만(최악의 경우
𝑁
!
N!나 부분집합 조합이지만),
가지치기를 통해 탐색 공간을 크게 줄일 수 있습니다.
백트래킹으로 각 패턴에 대해 “어디에 배정할지” 결정하면서 동시에 그룹의 제약 조건을 업데이트하는 방식은,
문제의 조건(패턴의 각 자리별 제약)을 자연스럽게 반영할 수 있는 방법입니다.
5. 문제를 백트래킹으로 풀기 위한 생각 정리
문제 재정의:

“패턴들을 호환 가능한 그룹으로 나누어, 최소 그룹 수로 분할하라.”
그룹(초염기서열) 개념 도입:

그룹은 각 자리별 제약 조건(어떤 문자가 있어야 하는지)을 담는 배열로 표현.
새로운 패턴이 들어왔을 때, 그룹과 충돌하지 않으면 그 그룹에 넣을 수 있다.
결정 문제로 전환:

각 패턴을 “어떤 그룹에 배정할지” 결정하는 문제로 바꿈.
이미 존재하는 그룹 중 호환되는 그룹이 있으면 거기에 넣고, 그렇지 않으면 새 그룹을 만들어 넣는다.
재귀적 탐색(백트래킹):

패턴 인덱스
𝑖
i부터 시작해, 하나씩 배정해 나가며 모든 패턴이 배정되면 그룹 수를 업데이트.
백트래킹 과정에서 “현재까지 사용한 그룹 수”를 추적하고,
만약 그 값이 현재까지 찾은 최소값 이상이면 더 이상 진행하지 않음.
상태 복원:

한 그룹에 패턴을 넣을 때 그룹의 제약 배열을 수정하므로,
재귀 호출 후 반드시 상태를 복원하여 다른 경우의 수 탐색에 영향이 없도록 함.
결론
백트래킹으로 이 문제를 풀 때는 패턴 배정 순서와 그룹 내 제약 조건의 업데이트를 어떻게 관리할지가 핵심입니다.
문제의 조건을 “각 그룹의 제약 조건”으로 정리하고, 각 패턴을 순서대로 처리하면서
“기존 그룹에 넣거나 새 그룹을 만드는” 두 가지 선택지를 재귀적으로 탐색하며,
가지치기를 통해 불필요한 경우를 줄이는 방식으로 문제를 해결할 수 있습니다.

이런 과정을 통해 문제를 백트래킹 방식으로 해결할 수 있게 됩니다.
 */